#!/usr/bin/perl
#*
# Extract essential data item descriptions (names, definitions) from
# DDLm dictionaries and write them out in .ttl format for inclusion
# into EMMO or other OWL ontologies.
#**

use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/lib/perl5/cif2ttl";
use lib "$Bin/../lib/perl5/cif2ttl";

use SOptions qw( getOptions );
use SUsage qw( usage );

use COD::CIF::Parser qw( parse_cif );
use Data::Dumper;

my $Id = '$Id 0.1.0$';

my $debug = 0;

my $parent_class; # Parent class ID in the OWL ontology
my $cif_category; # CIF category to process

#* OPTIONS:
#* --category cell
#*      Specify CIF category to process.
#*
#* --parent-class 18f45d3a-8354-11eb-8ca6-57869d351dfa
#*      Which OWL parent class should the category items be added to.
#*
#* --debug          Activate debug outputs
#* --no-debug       No debug outputs
#* --version        Print version number and exit
#* --help, --usage  Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--debug" => sub { $debug = 1 },
    "--no-debug,--dont-debug" => sub { $debug = 0 },
    "--category" => \$cif_category,
    "--parent-class" => \$parent_class,
    "--version" => sub {
        $Id =~ s/^\$|\$$//g;
        print $Id, "\n";
        print &get_version_string, "\n"; exit; },
    "--help,--usage" => sub { SUsage::usage(); exit; }
);

for my $file (@ARGV) {
    my ($cif, $err_count, $messages) = parse_cif( $file );
    if( $err_count == 0 ) {
        ## print Dumper $cif;
        for my $data_block (@$cif) {
            my $save_blocks = $data_block->{save_blocks};
            for my $save_block (@$save_blocks) {
                ##print ">>> ==== $save_block->{name} ====\n";
                ##print Dumper $save_block;
                my @block_data = traverse_save_block( $save_block );
                do {
                    for my $block_data (@block_data) {
                        my @keys = sort keys %$block_data;
                        for my $key (@keys) {
                            print "$key: $block_data->{$key}\n";
                        }
                        print "\n";
                    }
                } if $debug;
            }
        }
    } else {
        die join( "\n", @$messages );
    }
}

# Traverse CIF save blocks as returned from the CIF::COD::Parser,
# extract information necessary for Turtle file formation and return
# that information as a plain hash.
#
# Arguments:
#
#    $save_block: The root save_ block to be traversed; the traversal
#          function DOES NOT yet descend recursively into save_ blocks
#          stored inside.
#
# Returns:
#    $data_hash => {
#        category => 'category name',
#    }

sub traverse_save_block
{
    my ($save_block) = @_;

    my %block_data;

    for my $key (qw(_name.category_id _name.object_id _definition.id 
                    _alias.definition_id _description.text)) {
        my $name = $key;
        $name =~ s/(\.|_)id$//;
        $name =~ s/^_name\./_/;
        if( $name =~ /_([a-z]+)/ ) {
            $name = $1;
        }

        if( exists $save_block->{values}{$key} ) {
            $block_data{$name} = $save_block->{values}{$key}[0];
        }

        if( $name eq 'description' && exists $block_data{$name} ) {
            $block_data{$name} =~ s/\s+/ /g;
            $block_data{$name} =~ s/^\s*|\s$//g;
        }
    }

    return ( \%block_data );
}
