#!/usr/bin/perl
#*
# Extract essential data item descriptions (names, definitions) from
# DDLm dictionaries and write them out in .ttl format for inclusion
# into EMMO or other OWL ontologies.
#**

use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/lib/perl5/cif2ttl";
use lib "$Bin/../lib/perl5/cif2ttl";

use SOptions qw( getOptions );
use SUsage qw( usage );

use COD::CIF::Parser qw( parse_cif );
use Data::Dumper;

my $Id = '$Id 0.1.0$';

my $debug = 0;

my $parent_class = 'a807a946_94bb_4cba_a433_31daf1d0a94c'; # Parent class ID in the OWL ontology
my $cif_category = 'cell'; # CIF category to process

my $skos_pref_label = '<http://www.w3.org/2004/02/skos/core#prefLabel>';
my $rdfs_label = $skos_pref_label;

my $description_name = 'emmo:EMMO_967080e5_2f42_4eb2_a3a9_c58143e835f9';

#* OPTIONS:
#* --use-rdfs-label
#* --use-skos-pref-label
#*      Specify which type of labels to use in the output.
#*
#* --category cell
#*      Specify CIF category to process.
#*
#* --parent-class a807a946_94bb_4cba_a433_31daf1d0a94c
#*      Which OWL parent class should the category items be added to.
#*
#* --debug          Activate debug outputs
#* --no-debug       No debug outputs
#* --version        Print version number and exit
#* --help, --usage  Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--use-rdfs-label"        => sub { $rdfs_label = 'rdfs:label' },
    "--use-skos-pref-label"   => sub { $rdfs_label = $skos_pref_label },
    "--debug"                 => sub { $debug = 1 },
    "--no-debug,--dont-debug" => sub { $debug = 0 },
    "--category"              => \$cif_category,
    "--parent-class"          => \$parent_class,
    "--version" => sub {
        $Id =~ s/^\$|\$$//g;
        print $Id, "\n";
        print &get_version_string, "\n"; exit; },
    "--help,--usage" => sub { SUsage::usage(); exit; }
);

my $spaces = " " x 43;

for my $file (@ARGV) {
    my ($cif, $err_count, $messages) = parse_cif( $file );
    if( $err_count == 0 ) {
        ## print Dumper $cif;
        for my $data_block (@$cif) {
            my $save_blocks = $data_block->{save_blocks};
            for my $save_block (@$save_blocks) {
                ##print ">>> ==== $save_block->{name} ====\n";
                ##print Dumper $save_block;
                my @block_data = traverse_save_block( $save_block );
                do {
                    for my $block_data (@block_data) {
                        my @keys = sort keys %$block_data;
                        for my $key (@keys) {
                            print "$key: $block_data->{$key}\n";
                        }
                        print "\n";
                    }
                } if $debug;
                for my $block_data (@block_data) {
                    if( exists $block_data->{category} &&
                        $block_data->{category} eq $cif_category ) {
                        my $uuid = `uuidgen`; # call a shell for now, as a quick hack...
                        chomp $uuid;
                        local $\ = "\n";
                        print "### http://emmo.info/emmo/cif#OWLClass_${uuid}";
                        print ":OWLClass_${uuid} rdf:type owl:Class ;";
                        print "${spaces}rdfs:subClassOf :OWLClass_${parent_class} ;";
                        if( exists $block_data->{description} ) {
                            $block_data->{description} =~ s/"/''/g;
                            if( $block_data->{description} =~ /\n/ ) {
                                print "${spaces}$description_name " .
                                    "\"\"\"$block_data->{description}\"\"\" ;";
                            } else {
                                print "${spaces}$description_name " .
                                    "\"$block_data->{description}\" ;";
                            }
                        }
                        print "${spaces}$rdfs_label \"$block_data->{definition}\"\@en .";
                        print "";
                    }
                }
            }
        }
    } else {
        die join( "\n", @$messages );
    }
}

# Traverse CIF save blocks as returned from the CIF::COD::Parser,
# extract information necessary for Turtle file formation and return
# that information as a plain hash.
#
# Arguments:
#
#    $save_block: The root save_ block to be traversed; the traversal
#          function DOES NOT yet descend recursively into save_ blocks
#          stored inside.
#
# Returns:
#    $data_hash => {
#        category => 'category name',
#    }

sub traverse_save_block
{
    my ($save_block) = @_;

    my %block_data;

    for my $key (qw(_name.category_id _name.object_id _definition.id 
                    _alias.definition_id _description.text)) {
        my $name = $key;
        $name =~ s/(\.|_)id$//;
        $name =~ s/^_name\./_/;
        if( $name =~ /_([a-z]+)/ ) {
            $name = $1;
        }

        if( exists $save_block->{values}{$key} ) {
            $block_data{$name} = $save_block->{values}{$key}[0];
        }

        if( 0 ) {
            if( $name eq 'description' && exists $block_data{$name} ) {
                $block_data{$name} =~ s/\s+/ /g;
                $block_data{$name} =~ s/^\s*|\s$//g;
            }
        }
    }

    return ( \%block_data );
}
